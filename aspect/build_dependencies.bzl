"""Aspects to build and collect project dependencies."""

def _package_dependencies_impl(target, ctx):
    file_name = target.label.name + ".target-info.txt"
    artifact_info_file = ctx.actions.declare_file(file_name)
    ctx.actions.write(
        artifact_info_file,
        _encode_target_info_proto(target),
    )

    return [OutputGroupInfo(
        ij_query_sync = target[DependenciesInfo].compile_time_jars.to_list(),
        artifact_info_file = [artifact_info_file],
    )]

DependenciesInfo = provider(
    "The out-of-project dependencies",
    fields = {
        "compile_time_jars": "a list of jars generated by targets",
        "target_to_artifacts": "a map between the target to its deps to its artifacts",
    },
)

def _encode_target_info_proto(target):
    contents = []
    for label, artifacts_paths in target[DependenciesInfo].target_to_artifacts.items():
        contents.append(
            struct(target = label, artifact_paths = artifacts_paths),
        )
    return proto.encode_text(struct(target = str(target.label), deps = contents))

package_dependencies = aspect(
    implementation = _package_dependencies_impl,
    required_aspect_providers = [[DependenciesInfo]],
)

def generates_idl_jar(target):
    if AndroidIdeInfo not in target:
        return False
    return target[AndroidIdeInfo].idl_class_jar != None

def _collect_dependencies_impl(target, ctx):
    label = str(target.label)
    included = False
    for inc in ctx.attr.include.split(","):
        if label.startswith(inc):
            if label[len(inc)] in [":", "/"]:
                included = True
                break
    if included and len(ctx.attr.exclude) > 0:
        for exc in ctx.attr.exclude.split(","):
            if label.startswith(exc):
                if label[len(exc)] in [":", "/"]:
                    included = False
                    break

    if included and ctx.rule.kind in ctx.attr.always_build_rules.split(","):
        included = False

    deps = []
    if hasattr(ctx.rule.attr, "deps"):
        deps += ctx.rule.attr.deps
    if hasattr(ctx.rule.attr, "exports"):
        deps += ctx.rule.attr.exports
    if hasattr(ctx.rule.attr, "_junit"):
        deps.append(ctx.rule.attr._junit)

    info_deps = [dep[DependenciesInfo] for dep in deps if DependenciesInfo in dep]

    trs = []
    target_to_artifacts = {}
    if not included:
        if info_deps:
            trs = [target[JavaInfo].compile_jars]
            target_to_artifacts = {
                label: [_output_relative_path(f.path) for f in target[JavaInfo].compile_jars.to_list()],
            }
        else:
            # For JavaInfo libraries which we don't follow any dependencies
            # we attribute all the transitive jars to them. This includes
            # all the proto variants.
            trs = [target[JavaInfo].transitive_compile_time_jars]
            target_to_artifacts = {
                label: [_output_relative_path(f.path) for f in target[JavaInfo].transitive_compile_time_jars.to_list()],
            }

    for info in info_deps:
        trs.append(info.compile_time_jars)
        target_to_artifacts.update(info.target_to_artifacts)

    if included and ctx.attr.generate_aidl_classes and generates_idl_jar(target):
        idl_jar = target[AndroidIdeInfo].idl_class_jar
        trs.append(depset([idl_jar]))

    cj = depset([], transitive = trs)
    return [
        DependenciesInfo(
            compile_time_jars = cj,
            target_to_artifacts = target_to_artifacts,
        ),
    ]

def _output_relative_path(path):
    """Get file path relative to the output path.

    Args:
         path: path of artifact path = (../repo_name)? + (root_fragment)? + relative_path

    Returns:
         path relative to the output path
    """
    if (path.startswith("blaze-out/")) or (path.startswith("bazel-out/")):
        # len("blaze-out/") or len("bazel-out/")
        path = path[10:]
    return path

collect_dependencies = aspect(
    implementation = _collect_dependencies_impl,
    provides = [DependenciesInfo],
    attr_aspects = ["deps", "exports", "_junit"],
    required_providers = [[JavaInfo]],
    attrs = {
        "include": attr.string(
            doc = "Comma separated list of workspace paths included in the project as source. Any targets inside here will not be built.",
            mandatory = True,
        ),
        "exclude": attr.string(
            doc = "Comma separated list of exclusions to 'include'.",
            default = "",
        ),
        "always_build_rules": attr.string(
            doc = "Comma separated list of rules. Any targets belonging to these rules will be built, regardless of location",
            default = "",
        ),
        "generate_aidl_classes": attr.bool(
            doc = "If True, generates classes for aidl files included as source for the project targets",
            default = False,
        ),
    },
)
